"""
Extract and validate nucleotide sequences from FASTA files based on positions and frame information
in protein sequence headers.
Assumes that protein sequence headers are in the format generated by ofipy:
>name name_ORF.3 [4-52](-) type:complete length:48 frame:-3 start:CTG stop:TAA

This script extracts nucleotide sequences that correspond to predicted open reading frames from
provided nucleotide sequences, adjusting for reading frame and reverse complementation. It also
validates that the extracted nucleotide sequence translates to the provided amino acid sequence.
"""

import argparse

import utils
from Bio import SeqIO


def extract_positions_and_frame(protein_header):
    """Extract start, end positions, and reading frame from the protein sequence header."""
    parts = protein_header.split()
    for part in parts:
        if "[" in part and "]" in part and "(" in part:
            position_part, frame_part = part.strip("[").split("(")
            position_part = position_part.strip("]")
            start, end = map(int, position_part.split("-"))
        if part.startswith("frame:"):
            frame = int(part.split("frame:")[-1])
    return start, end, frame


def process_by_positions_and_frame(seq, start, end, frame):
    """Extract the Handle reverse complementation based on frame."""
    seq = seq[start:end]
    if frame < 0:
        seq = seq.reverse_complement()
    return seq


def extract_nucleotide_peptide_sequences(
    nucleotide_fasta_file, protein_peptides_fasta_file, nucleotide_peptides_output_file
):
    """
    Extract and validate nucleotide sequences for plmutils-predicted peptides based on the FASTA
    headers of the peptide protein sequences.
    """
    nucleotide_sequences = SeqIO.to_dict(SeqIO.parse(nucleotide_fasta_file, "fasta"))
    nucleotide_peptide_records = []

    for peptide_record in SeqIO.parse(protein_peptides_fasta_file, "fasta"):
        transcript_id = peptide_record.id
        start, end, frame = extract_positions_and_frame(peptide_record.description)
        nucleotide_peptide_sequence = process_by_positions_and_frame(
            nucleotide_sequences[transcript_id].seq, start, end, frame
        )
        protein_peptide_sequence = peptide_record.seq
        if not utils.verify_translation(
            nucleotide_peptide_sequence, protein_peptide_sequence, to_stop=False
        ):
            raise ValueError(
                f"Warning: Translation mismatch for {transcript_id}. "
                "Check the reading frame and positions."
            )
        
        output_record = peptide_record
        output_record.seq = nucleotide_peptide_sequence
        nucleotide_peptide_records.append(output_record)

    SeqIO.write(nucleotide_peptide_records, nucleotide_peptides_output_file, "fasta")


def main():
    parser = argparse.ArgumentParser(
        description="Extract specific nucleotide sequences based on protein sequence headers."
    )

    parser.add_argument(
        "-n", "--nucleotide_fasta_file", required=True, help="Path to the nucleotide FASTA file."
    )
    parser.add_argument(
        "-p",
        "--protein_peptides_fasta_file",
        required=True,
        help="Path to the predicted peptide protein sequences FASTA file.",
    )
    parser.add_argument(
        "-o",
        "--nucleotide_peptides_output_file",
        required=True,
        help="Output path for the extracted nucleotide sequences.",
    )

    args = parser.parse_args()
    extract_nucleotide_peptide_sequences(
        args.nucleotide_fasta_file,
        args.protein_peptides_fasta_file,
        args.nucleotide_peptides_output_file,
    )


if __name__ == "__main__":
    main()
