"""
Extract and validate nucleotide sequences from FASTA files based on positions and frame information
in protein sequence headers.
Assumes that protein sequence headers are in the format generated by ofipy:
>name name_ORF.3 [4-52](-) type:complete length:48 frame:-3 start:CTG stop:TAA

This script extracts nucleotide sequences that correspond to predicted open reading frames from
provided nucleotide sequences, adjusting for reading frame and reverse complementation. It also
validates that the extracted nucleotide sequence translates to the provided amino acid sequence.
"""

import argparse

from Bio import SeqIO


def extract_positions_and_frame(protein_header):
    """Extract start, end positions, and reading frame from the protein sequence header."""
    parts = protein_header.split()
    for part in parts:
        if "[" in part and "]" in part and "(" in part:
            position_part, frame_part = part.strip("[").split("(")
            position_part = position_part.strip("]")
            start, end = map(int, position_part.split("-"))
        if part.startswith("frame:"):
            frame = int(part.split("frame:")[-1])
    return start, end, frame


def process_sequence(seq, start, end, frame):
    """Adjust positions for start/stop codons and handle reverse complementation based on frame."""
    # start_adj, end_adj = start - 1 - 3, end + 3  # Adjust for start and stop codons
    if frame < 0:
        return seq[start:end].reverse_complement()
    else:
        return seq[start:end]


def validate_translation(nucleotide_seq, amino_acid_seq):
    """Validate that the nucleotide sequence translates to the expected amino acid sequence."""
    translated_seq = nucleotide_seq.translate()
    return translated_seq == amino_acid_seq


def extract_nucleotide_sequences(nucleotide_fasta, protein_fasta, output_fasta):
    """Extract and validate nucleotide sequences based on protein FASTA headers."""
    nucleotide_seqs = SeqIO.to_dict(SeqIO.parse(nucleotide_fasta, "fasta"))

    with open(output_fasta, "w") as output_handle:
        for protein_record in SeqIO.parse(protein_fasta, "fasta"):
            transcript_id = protein_record.id
            amino_acid_seq = protein_record.seq
            start, end, frame = extract_positions_and_frame(protein_record.description)
            nucleotide_seq = process_sequence(nucleotide_seqs[transcript_id].seq, start, end, frame)
            if not validate_translation(nucleotide_seq, amino_acid_seq):
                print(
                    f"Warning: Translation mismatch for {transcript_id}. "
                    "Check the reading frame and positions."
                )
                continue
            output_record = protein_record
            output_record.seq = nucleotide_seq
            SeqIO.write(output_record, output_handle, "fasta")


def main():
    parser = argparse.ArgumentParser(
        description="Extract specific nucleotide sequences based on " "protein sequence headers."
    )

    parser.add_argument(
        "-n", "--nucleotide_fasta", required=True, help="Path to the nucleotide FASTA file."
    )
    parser.add_argument(
        "-p",
        "--protein_fasta",
        required=True,
        help="Path to the predicted protein sequences FASTA file.",
    )
    parser.add_argument(
        "-o",
        "--output_fasta",
        required=True,
        help="Output path for the extracted nucleotide sequences.",
    )

    args = parser.parse_args()
    extract_nucleotide_sequences(args.nucleotide_fasta, args.protein_fasta, args.output_fasta)
    args = parser.parse_args()
    extract_nucleotide_sequences(args.nucleotide_fasta, args.protein_fasta, args.output_fasta)


if __name__ == "__main__":
    main()
